import { FetchOptions } from 'ofetch';

type MetadataMap = Record<string, unknown>;
type IPFS_PATH = `/ipfs/${string}`;
type IPNS_PATH = `/ipns/${string}`;
type IPFS_HASH = `Qm${string}` | `ba${string}`;
type HTTPS_URI = `https://${string}`;
type IPFS_URI = `ipfs://${string}`;
type ARWEAVE_URI = `ar://${string}`;
type IPFS = IPFS_PATH | IPNS_PATH | IPFS_HASH | IPFS_URI;
type URI = HTTPS_URI | IPFS | ARWEAVE_URI;
type Formatter = <T>(uri: string) => T;
type SanitizedOutput = {
    path: HTTPS_URI | IPFS;
    needProvider: boolean;
    formatter?: Formatter;
};
type Callback<T = any, V = any> = (param: T) => Promise<V>;
type UnwrapCallback<T> = (param: T) => string;
type FetchCallback<T> = (param: URI) => Promise<T>;

declare const toArweavePath: (uri: string) => HTTPS_URI;

declare const isCID: (uri: string) => boolean;
declare const isHTTP: (uri: string) => boolean;
declare const isPath: (uri: string) => boolean;
declare const isFullPath: (uri: string) => boolean;
declare const isFetchable: (uri: string) => boolean;
declare const toIPFSPath: (uri: string) => IPFS_HASH | IPFS_PATH | IPNS_PATH;
declare function isDefaultPinataProvider(uri: string): boolean;
declare const canBeIPFS: (uri: string) => boolean;
declare const extractIPFS: (uri: string) => IPFS_HASH | IPFS_PATH | IPNS_PATH;

declare const IPFS_FS_PREFIX = "ipfs://ipfs/";
declare const IPFS_NS_PREFIX = "ipfs://ipns/";
declare const IPFS_PREFIX = "ipfs://";
declare const IPNS_PREFIX = "ipns://";
declare const HTTP_REGEX: RegExp;
declare const ARWEAVE_REGEX: RegExp;
declare const IPFS_REGEX: RegExp;
declare const SMART_IPFS_REGEX: RegExp;

declare const PINATA_GATEWAY: HTTPS_URI;
type IPFSProviders = 'apillon' | 'aragon' | 'astyanax' | 'cf' | 'cloudflare' | 'dweb' | 'filebase_kodadot' | 'fleek' | 'gateway' | 'infura' | 'infura_kodadot1' | 'ipfs' | 'kodadot' | 'kodadot_beta' | 'nftstorage' | 'rmrk';
type AvailableProviders = IPFSProviders[];
declare const ipfsProviders: Record<IPFSProviders, HTTPS_URI>;
declare const getProviderList: (providers?: AvailableProviders) => HTTPS_URI[];
declare const getProperURI: (uri: IPFS_PATH | IPNS_PATH, providers?: AvailableProviders) => HTTPS_URI[];
declare const getGatewayURI: (uri: IPFS_PATH | IPNS_PATH) => (provider: IPFSProviders) => HTTPS_URI;

declare function $obtain<T>(uri: URI | string, providers?: AvailableProviders, fast?: boolean): Promise<T>;
declare function $purify(uri: URI | string, providers?: AvailableProviders): HTTPS_URI[];

declare function obtain<T>(uri: URI, options?: FetchOptions<'json'>): Promise<T>;
declare function obtainSafe<T>(uri: URI): Promise<T>;
declare function obtainFast<T>(uri: URI): Promise<T>;
declare function obtainMedia(uri: URI): Promise<Blob>;
declare function obtainMimeType(uri: URI): Promise<string>;

declare function competition<T>(path: IPFS_PATH | IPNS_PATH, providers: AvailableProviders, callback: FetchCallback<T>): Promise<T>;

declare function sanitize(path: string): SanitizedOutput;

export { $obtain, $purify, ARWEAVE_REGEX, ARWEAVE_URI, AvailableProviders, Callback, FetchCallback, Formatter, HTTPS_URI, HTTP_REGEX, IPFS, IPFSProviders, IPFS_FS_PREFIX, IPFS_HASH, IPFS_NS_PREFIX, IPFS_PATH, IPFS_PREFIX, IPFS_REGEX, IPFS_URI, IPNS_PATH, IPNS_PREFIX, MetadataMap, PINATA_GATEWAY, SMART_IPFS_REGEX, SanitizedOutput, URI, UnwrapCallback, canBeIPFS, competition, extractIPFS, getGatewayURI, getProperURI, getProviderList, ipfsProviders, isCID, isDefaultPinataProvider, isFetchable, isFullPath, isHTTP, isPath, obtain, obtainFast, obtainMedia, obtainMimeType, obtainSafe, sanitize, toArweavePath, toIPFSPath };
