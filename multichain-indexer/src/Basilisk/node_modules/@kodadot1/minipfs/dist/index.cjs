'use strict';

const ofetch = require('ofetch');

const IPFS_FS_PREFIX = "ipfs://ipfs/";
const IPFS_NS_PREFIX = "ipfs://ipns/";
const IPFS_PREFIX = "ipfs://";
const IPNS_PREFIX = "ipns://";
const HTTP_REGEX = /^https?:\/\//;
const ARWEAVE_REGEX = /^ar:\/\//;
const IPFS_REGEX = /^ipfs:\/\//;
const SMART_IPFS_REGEX = /^ipfs:\/\/(ip[fn]s\/)?(baf|Qm)/;

const ARWEAVE_BASE = "https://arweave.net/";
const toArweavePath = (uri) => {
  const hash = uri.replace(ARWEAVE_REGEX, "");
  return `${ARWEAVE_BASE}${hash}`;
};

const PINATA_GATEWAY = "https://gateway.pinata.cloud";
const ipfsProviders = {
  apillon: "https://ipfs.apillon.io",
  aragon: "https://ipfs.eth.aragon.network",
  astyanax: "https://ipfs.astyanax.io",
  cf: "https://cf-ipfs.com",
  cloudflare: "https://cloudflare-ipfs.com",
  dweb: "https://dweb.link",
  filebase_kodadot: "https://kodadot-ultra.myfilebase.com",
  fleek: "https://ipfs.fleek.co",
  gateway: "https://gateway.ipfs.io",
  infura: "https://infura-ipfs.io",
  infura_kodadot1: "https://kodadot1.infura-ipfs.io",
  ipfs: "https://ipfs.io",
  kodadot: "https://image.w.kodadot.xyz",
  kodadot_beta: "https://image-beta.w.kodadot.xyz",
  nftstorage: "https://nftstorage.link",
  rmrk: "https://ipfs2.rmrk.link"
};
const DEFAULT_PROVIDER_LIST = [
  "kodadot",
  "filebase_kodadot"
];
const getProviderList = (providers = DEFAULT_PROVIDER_LIST) => {
  const list = providers.length ? providers : DEFAULT_PROVIDER_LIST;
  return list.map((provider) => ipfsProviders[provider]);
};
const getProperURI = (uri, providers = []) => {
  const providerList = getProviderList(providers);
  return providerList.map((provider) => `${provider}${uri}`);
};
const getGatewayURI = (uri) => (provider) => {
  return `${ipfsProviders[provider]}${uri}`;
};

const isV0Cid = (cid) => {
  return cid.length === 46 && cid.startsWith("Qm");
};
const isV1Cid = (cid) => {
  return cid.length === 59 && cid.startsWith("baf");
};
const isCID = (uri) => {
  return isV0Cid(uri) || isV1Cid(uri);
};
const isHTTP = (uri) => {
  return HTTP_REGEX.test(uri);
};
const isPath = (uri) => {
  return /^\/ip[fn]s\//.test(uri);
};
const isFullPath = (uri) => {
  return SMART_IPFS_REGEX.test(uri);
};
const isFetchable = (uri) => {
  return isCID(uri) || isHTTP(uri) || isPath(uri) || isFullPath(uri);
};
const toIPFSPath = (uri) => {
  if (isCID(uri)) {
    return `/ipfs/${uri}`;
  }
  if (isPath(uri)) {
    return uri;
  }
  throw new TypeError(`Invalid IPFS URI: ${uri}`);
};
function isDefaultPinataProvider(uri) {
  return uri.startsWith(PINATA_GATEWAY);
}
const canBeIPFS = (uri) => {
  return isCID(uri) || isPath(uri);
};
const extractIPFS = (uri) => {
  if (uri.startsWith(IPFS_FS_PREFIX) || uri.startsWith(IPFS_NS_PREFIX)) {
    return uri.replace("ipfs:/", "");
  }
  if (uri.startsWith(IPFS_PREFIX) || uri.startsWith(IPNS_PREFIX)) {
    const value = uri.replace(":/", "");
    return "/" + value;
  }
  return uri.replace(IPFS_PREFIX, "");
};

function obtain(uri, options) {
  return ofetch.$fetch(uri, {
    retry: 3,
    mode: "no-cors",
    redirect: "follow",
    ...options,
    onRequestError({ error, request }) {
      const message = `[KODADOT::MINIPFS] Fail to Obtain ${request}: ${error.message}`;
      console.warn(message);
    },
    onResponseError({ request, response }) {
      const message = `[KODADOT::MINIPFS] Obtaininig ${request} failed with status ${response.status}`;
      console.warn(message);
    }
  });
}
async function obtainSafe(uri) {
  try {
    return await obtain(uri);
  } catch (err) {
    return {};
  }
}
function obtainFast(uri) {
  return obtain(uri, { signal: AbortSignal.timeout(8e3) });
}
function obtainMedia(uri) {
  return ofetch.$fetch(uri, { responseType: "blob" });
}
async function obtainMimeType(uri) {
  const { type } = await ofetch.$fetch(uri, { method: "HEAD" });
  return type;
}

function competition(path, providers = [], callback) {
  const providerList = getProviderList(providers);
  const urls = providerList.map((provider) => `${provider}${path}`).map((uri) => callback(uri));
  return Promise.any(urls);
}

function isBaseSixtyFour(data) {
  return /^data:([a-z]+)\/([\.\-\+a-z]+);base64,/.test(data);
}
function isBaseSixtyFourJSON(data) {
  return /^data:application\/json;base64,/.test(data);
}
function canBeJSON(data) {
  return data.startsWith("{") && data.endsWith("}") || data.startsWith("[") && data.endsWith("]");
}
function fromBaseSixtyFour(data) {
  if (isBaseSixtyFour(data)) {
    return atob(data.split(",").at(1));
  }
  return "";
}
function baseSixtyFourFormatter(data) {
  if (isBaseSixtyFourJSON(data)) {
    return JSON.parse(fromBaseSixtyFour(data));
  }
  return fromBaseSixtyFour(data);
}

function sanitize(path) {
  if (canBeIPFS(path)) {
    return { path: toIPFSPath(path), needProvider: true };
  }
  if (canBeJSON(path)) {
    return {
      path,
      needProvider: false,
      formatter: JSON.parse
    };
  }
  if (isBaseSixtyFour(path)) {
    return {
      path,
      needProvider: false,
      formatter: baseSixtyFourFormatter
    };
  }
  if (IPFS_REGEX.test(path)) {
    return { path: toIPFSPath(extractIPFS(path)), needProvider: true };
  }
  if (HTTP_REGEX.test(path)) {
    if (isDefaultPinataProvider(path)) {
      return {
        path: path.replace(PINATA_GATEWAY, ""),
        needProvider: true
      };
    }
    return { path, needProvider: false };
  }
  if (ARWEAVE_REGEX.test(path)) {
    return { path: toArweavePath(path), needProvider: false };
  }
  throw new Error(`[KODADOT::MINIPFS] Invalid URI: ${path}`);
}

function $obtain(uri, providers = [], fast) {
  const { needProvider, path, formatter } = sanitize(uri);
  const callback = fast ? obtainFast : obtain;
  if (formatter) {
    return Promise.resolve(formatter(path));
  }
  if (needProvider) {
    return competition(path, providers, callback);
  }
  return callback(path);
}
function $purify(uri, providers = []) {
  const { needProvider, path } = sanitize(uri);
  if (needProvider) {
    return getProperURI(path, providers);
  }
  return [path];
}

exports.$obtain = $obtain;
exports.$purify = $purify;
exports.ARWEAVE_REGEX = ARWEAVE_REGEX;
exports.HTTP_REGEX = HTTP_REGEX;
exports.IPFS_FS_PREFIX = IPFS_FS_PREFIX;
exports.IPFS_NS_PREFIX = IPFS_NS_PREFIX;
exports.IPFS_PREFIX = IPFS_PREFIX;
exports.IPFS_REGEX = IPFS_REGEX;
exports.IPNS_PREFIX = IPNS_PREFIX;
exports.PINATA_GATEWAY = PINATA_GATEWAY;
exports.SMART_IPFS_REGEX = SMART_IPFS_REGEX;
exports.canBeIPFS = canBeIPFS;
exports.competition = competition;
exports.extractIPFS = extractIPFS;
exports.getGatewayURI = getGatewayURI;
exports.getProperURI = getProperURI;
exports.getProviderList = getProviderList;
exports.ipfsProviders = ipfsProviders;
exports.isCID = isCID;
exports.isDefaultPinataProvider = isDefaultPinataProvider;
exports.isFetchable = isFetchable;
exports.isFullPath = isFullPath;
exports.isHTTP = isHTTP;
exports.isPath = isPath;
exports.obtain = obtain;
exports.obtainFast = obtainFast;
exports.obtainMedia = obtainMedia;
exports.obtainMimeType = obtainMimeType;
exports.obtainSafe = obtainSafe;
exports.sanitize = sanitize;
exports.toArweavePath = toArweavePath;
exports.toIPFSPath = toIPFSPath;
