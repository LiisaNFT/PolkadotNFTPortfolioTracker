import { In } from 'typeorm';
import { c as toMap, g as toEntity } from './shared/metasquid.4a3018bb.mjs';
import 'scule';

async function createOrElseThrow(store, entityConstructor, id, init) {
  const entity = await getOptional(store, entityConstructor, id);
  if (entity) {
    throw new Error(`Entity with id ${id} already exists`);
  }
  return create(entityConstructor, id, init);
}
async function getOrCreate(store, entityConstructor, id, init) {
  let entity = await getOptional(store, entityConstructor, id);
  if (entity == null) {
    entity = new entityConstructor();
    entity.id = id;
    Object.assign(entity, init);
  }
  return entity;
}
function get(store, entityConstructor, id) {
  return getOptional(store, entityConstructor, id);
}
function getOptional(store, entityConstructor, id) {
  const where = { id };
  return store.findOneBy(entityConstructor, where);
}
function getOrFail(store, entityConstructor, id) {
  const where = { id };
  return store.findOneByOrFail(entityConstructor, where);
}
function getWhere(store, entityConstructor, id, where) {
  const options = { id, ...where };
  return store.findOneByOrFail(entityConstructor, options);
}
function create(entityConstructor, id, init) {
  const entity = new entityConstructor();
  entity.id = id;
  Object.assign(entity, init);
  return entity;
}
function findOne(store, entityConstructor, id, options) {
  const where = { id };
  return store.findOne(entityConstructor, { ...options, where });
}
function findOneWithJoin(store, entityConstructor, id, relations) {
  return findOne(store, entityConstructor, id, { relations });
}
function findByIdList(store, entityConstructor, idList) {
  const where = {
    id: In([...idList])
  };
  return store.findBy(entityConstructor, where);
}
function findByIdListAsMap(store, entityConstructor, idList) {
  return findByIdList(store, entityConstructor, idList).then(toMap);
}
function findByRawQuery(store, entityConstructor, query, args) {
  const repository = store.getRepository(entityConstructor);
  return genericRepositoryQuery(repository, query, args).then((res) => res.map((el) => toEntity(entityConstructor, el)));
}
function has(store, entityConstructor, idOrOptions) {
  const where = typeof idOrOptions === "string" ? { id: idOrOptions } : idOrOptions;
  return store.exists(entityConstructor, { where });
}
function genericRepositoryQuery(repository, query, args) {
  return repository.query(query, args);
}

export { create, createOrElseThrow, findByIdList, findByIdListAsMap, findByRawQuery, findOneWithJoin, genericRepositoryQuery, get, getOptional, getOrCreate, getOrFail, getWhere, has };
