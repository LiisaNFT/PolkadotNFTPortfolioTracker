'use strict';

const typeorm = require('typeorm');
const shared = require('./shared/metasquid.26b5e105.cjs');
require('scule');

async function createOrElseThrow(store, entityConstructor, id, init) {
  const entity = await getOptional(store, entityConstructor, id);
  if (entity) {
    throw new Error(`Entity with id ${id} already exists`);
  }
  return create(entityConstructor, id, init);
}
async function getOrCreate(store, entityConstructor, id, init) {
  let entity = await getOptional(store, entityConstructor, id);
  if (entity == null) {
    entity = new entityConstructor();
    entity.id = id;
    Object.assign(entity, init);
  }
  return entity;
}
function get(store, entityConstructor, id) {
  return getOptional(store, entityConstructor, id);
}
function getOptional(store, entityConstructor, id) {
  const where = { id };
  return store.findOneBy(entityConstructor, where);
}
function getOrFail(store, entityConstructor, id) {
  const where = { id };
  return store.findOneByOrFail(entityConstructor, where);
}
function getWhere(store, entityConstructor, id, where) {
  const options = { id, ...where };
  return store.findOneByOrFail(entityConstructor, options);
}
function create(entityConstructor, id, init) {
  const entity = new entityConstructor();
  entity.id = id;
  Object.assign(entity, init);
  return entity;
}
function findOne(store, entityConstructor, id, options) {
  const where = { id };
  return store.findOne(entityConstructor, { ...options, where });
}
function findOneWithJoin(store, entityConstructor, id, relations) {
  return findOne(store, entityConstructor, id, { relations });
}
function findByIdList(store, entityConstructor, idList) {
  const where = {
    id: typeorm.In([...idList])
  };
  return store.findBy(entityConstructor, where);
}
function findByIdListAsMap(store, entityConstructor, idList) {
  return findByIdList(store, entityConstructor, idList).then(shared.toMap);
}
function findByRawQuery(store, entityConstructor, query, args) {
  const repository = store.getRepository(entityConstructor);
  return genericRepositoryQuery(repository, query, args).then((res) => res.map((el) => shared.toEntity(entityConstructor, el)));
}
function has(store, entityConstructor, idOrOptions) {
  const where = typeof idOrOptions === "string" ? { id: idOrOptions } : idOrOptions;
  return store.exists(entityConstructor, { where });
}
function genericRepositoryQuery(repository, query, args) {
  return repository.query(query, args);
}

exports.create = create;
exports.createOrElseThrow = createOrElseThrow;
exports.findByIdList = findByIdList;
exports.findByIdListAsMap = findByIdListAsMap;
exports.findByRawQuery = findByRawQuery;
exports.findOneWithJoin = findOneWithJoin;
exports.genericRepositoryQuery = genericRepositoryQuery;
exports.get = get;
exports.getOptional = getOptional;
exports.getOrCreate = getOrCreate;
exports.getOrFail = getOrFail;
exports.getWhere = getWhere;
exports.has = has;
