"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setUpRelations = void 0;
const util_internal_1 = require("@subsquid/util-internal");
function setUpRelations(block) {
    block.transactions.sort((a, b) => a.transactionIndex - b.transactionIndex);
    block.logs.sort((a, b) => a.logIndex - b.logIndex);
    block.traces.sort(traceCompare);
    let txs = new Array(((0, util_internal_1.maybeLast)(block.transactions)?.transactionIndex ?? -1) + 1);
    for (let tx of block.transactions) {
        txs[tx.transactionIndex] = tx;
    }
    for (let rec of block.logs) {
        let tx = txs[rec.transactionIndex];
        if (tx) {
            rec.transaction = tx;
            tx.logs.push(rec);
        }
    }
    for (let i = 0; i < block.traces.length; i++) {
        let rec = block.traces[i];
        let tx = txs[rec.transactionIndex];
        if (tx) {
            rec.transaction = tx;
            tx.traces.push(rec);
        }
        if (i > 0) {
            let prev = block.traces[i - 1];
            if (isChild(prev, rec)) {
                rec.parent = prev;
                populateSubtraces(prev, rec);
            }
        }
    }
    for (let rec of block.stateDiffs) {
        let tx = txs[rec.transactionIndex];
        if (tx) {
            rec.transaction = tx;
            tx.stateDiffs.push(rec);
        }
    }
}
exports.setUpRelations = setUpRelations;
function traceCompare(a, b) {
    return a.transactionIndex - b.transactionIndex || addressCompare(a.traceAddress, b.traceAddress);
}
function addressCompare(a, b) {
    for (let i = 0; i < Math.min(a.length, b.length); i++) {
        let order = a[i] - b[i];
        if (order)
            return order;
    }
    return a.length - b.length; // this differs from substrate call ordering
}
function isChild(parent, child) {
    if (parent.transactionIndex != child.transactionIndex)
        return false;
    if (parent.traceAddress.length > child.traceAddress.length)
        return false;
    for (let i = 0; i < parent.traceAddress.length; i++) {
        if (parent.traceAddress[i] != child.traceAddress[i])
            return false;
    }
    return true;
}
function populateSubtraces(parent, child) {
    while (parent) {
        parent.children.push(child);
        parent = parent.parent;
    }
}
//# sourceMappingURL=relations.js.map